<!--
.. title: Making Music With No-input Mixer, SuperCollider, and Tidal
.. slug: mixer-supercollider-tidal-music
.. date: 2017-01-09 18:26:25 UTC-05:00
.. tags:
.. category:
.. link:
.. description:
.. type: text
-->

## No-input mixer

Years ago I one of [these](http://usa.yamaha.com/products/live_sound/mixers/analog-mixers/mg102c/) cheap mixers so I could record and amplify dorm room nonsense music sessions. But at Dartmouth I had access to better recording facilities and the mixer was gathering dust. Cool dude [Carlos Dominguez](https://charlossound.wordpress.com/) had introduced me to the concept of "no-input" mixing. Normally a mixer is the middleman between an instrument or microphone and a loudspeaker or recording device. It alters and facilitates sounds, but doesn't make sound. No-input mixing is total misuse of the mixer: you plug the mixer back into itself, as its own sole input. The mixer self-oscillates and makes its own sounds. It's the same principle as an electric guitar feeding back, or plugging a bunch of effects pedals together in a loop, or how analog synthesizers work under the hood. What's funny and exciting about the no-input mixer is how rich and diverse it sounds given that it isn't supposed to sound at all. The whole point of a mixer is to have fine control over routing and EQ; even a smallish stereo mixer has endless possible configurations. And because the oscillations depend on a delicate balance of amplification, it is an enormously sensitive instrument. Playing it means moving a single knob *so slowly* to find the precise edge of chaos between two sounds; sweeping it *so quickly* to carve a tiny blip out of a squall; listening *so closely* to know when it's about to blow up. You learn the feel of a particular mixer, but it's still new every time. For some masterful no-input mixing, check out [Toshimaru Nakamura](https://en.wikipedia.org/wiki/Toshimaru_Nakamura).

As rich and surprisingly large as the space of feedback mixer sounds is, it's pretty distinctly within noise-drone-ambient world. You can make a lovely drone, you can make a wall of noise, you can make little squawking sounds, you can float through space. But I found myself yearning to hold on to one sound while searching for its perfect complement, or to condense a minute's worth of exploration into a short pattern, or to build whole stacks of sounds and rapidly switch between them. One option would be to ravenously seek *more channels*, but lacking a bigger mixer to abuse I turned to my old friend, computers. At first I just ran the mixer into Ableton. Simple stuff like grabbing a loop while continuing to tweak the mixer, or stacking a weird noisy tone into a weird noisy chord. Once the computer's in the loop, you can also expand the mixer's vocabulary by feeding processed sound back into the mixer. Slight [frequency shifting](https://en.wikipedia.org/wiki/Single-sideband_modulation) of 0.1-10 Hz and reverb are particularly fertile. "Senseless Noise feat. Jeff" is an extremely goofy example of this setup, with me twirling the knobs and cool dude Jeff Mentch playfully tickling the default Ableton percussion synth. Also there are some blippy sine waves.

<iframe width="100%" height="166" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/247613308&amp;color=ff5500&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false"></iframe>

## Live Coding

Using a big nasty rigid-yet-complex GUI like Ableton with the no-input mixer felt all wrong; it's nice for recording and has a powerful sampler, but it really spoils the elegance of the no-input mixer. And it demands the extra moving part of a MIDI controller or at least a mouse. So lately I've been learning to use two live-coding music languages, [SuperCollider](http://supercollider.github.io/) and [Tidal](https://tidalcycles.org/).

SuperCollider is two things: a flexible software synthesizer *scsynth* and a scripting language to control it, *sclang*. (Really three, there's also the development environment *scide*). In SuperCollider, you build synthesizers as graphs of unit generators which do simple things like generate a sine wave, delay a signal, apply a filter. Sclang lets you do things which are tedious in a program like Max or Ableton and impossible with hardware, like "make 100 versions of this sound and spread them across the stereo field" or "randomize all the connections between these synthesizers". It does come with a steep learning curve. Sclang has a funny syntax with some gotchas like "literals can't start with `.`" and "single letter names are special global variables" and "functions are first class but you have to call them by accessing their `value` field or there's a special shorthand `f.(args)` which just looks weird". There are always several programming paradigms and syntax options to choose from. The separation between scsynth and sclang takes a while to wrap your head around. Scsynth and scide can be temperamental. Errors aren't very informative. It's enough to drive you off when you're starting out and just want to make a weird chord out of 100 sine waves. Nevertheless, I've been getting the hang of it and having a blast dreaming up wacky delay effects to use with the mixer.

Tidal is complementary to SuperCollider. It doesn't deal directly with sound, but focuses on music as a sequence of discrete events. Like Ableton, it enshrines pulse as fundamental. Very unlike Ableton, it brings all the machinery of maximally-dorky pure functional programming to bear on the process of defining musical patterns. Tidal is two things: a sublanguage of [Haskell](https://www.haskell.org/) with its own special "pattern" literal, and a runtime which maintains a clock and emits OSC messages. I found it easy to jump in, but only because I already spent some time quality time with Haskell and functional programming in a PL class. It's abstract as hell. [This silly book](http://learnyouahaskell.com/) is a good introduction. Tidal tries pretty hard to be friendly, but until you understand what the `$` operator means you will have a bad time. Tidal can send arbitrary MIDI and OSC, but it's really made to use with its own special sampler called Dirt (which has a SuperCollider implementation). I've been recording trajectories of a few minutes through computer-augmented no-input mixer space, then using Tidal+Dirt to chop them up into patterns. "Improv December 17" is all mixer plus a single kick drum sample that comes with Dirt.

<iframe width="100%" height="166" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/298537508&amp;color=ff5500&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false"></iframe>

Tidal and Dirt are pretty experimental software, and there are some rough edges. Not all the documentation is there, and some things just aren't working for me. Sometimes samples don't fade in right and pop, the built in delay effect is acting bizarrely, and it can be awkward to deal with long samples. Right off the bat, I had to build the latest version to fix a fatal bug. There are some sampler features I miss like having expressive envelopes; I'd also like more flexible EQ. If I can get fluent at SuperCollider, I may try to implement some of it myself!

So far all my SuperCollider and Tidal work is live-coded spaghetti, but when I have some real time to dedicate I hope to pack some of it into nice libraries. Stay tuned!

Side note: I nuked my old Windows desktop to turn it into an Ubuntu server/workstation for machine learning stuff. Tidal and SuperCollider are cross platform, but I normally use Ableton or Reaper for a DAW, which don't run under Linux. So I tried out [Ardour](https://ardour.org/) for the first time in years. I was very impressed until I discovered that automation curves wouldn't draw right. So close! If I can get to the bottom of that, I'll have little reason to leave Linux again. Since I hadn't set up multichannel recording for Dirt and SuperCollider yet, I needed to aggressively master a dry stereo recording. I tried out the free [Calf plugins](http://calf-studio-gear.org/), which are very flexible and sound great. I guess they've been around for a while, but I never knew about them before.
